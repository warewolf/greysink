REMEMBER: EVERYTHING IS ASYNC PASSING STATE.

SHOWSTOPPER: need TCP support!
 - UDP queries can come in - and get an overly large response. We respond in UDP.
 - check for tc flag: print "packet is ", $packet->header->tc ? "" : "not ", "truncated\n";
 - Client notices the response was truncated, and retries in TCP to get the full response.
   - Two problems: how do we truncate our response, and we need to listen on TCP.
   - Check if the recursive resolver code supports TCP.
 - POE::Filter::DNS::TCP handles parsing of TCP DNS packets in POE.

To inotify for data file change(s):
 - set up inline states for monitoring the file
 - inotify must send an event to its own session first, then my code can send events to other sessions

EVENT FLOW:

Query comes in to ::Sever
 - ::Server stores response callback in $_[HEAP]->{.. sockaddr .. query ..}, for later use
 - ::Server passes query class/type/record to all ::Sink modules, with postback(?) w/ args containing class/type/record
   - ::Sink modules postback to ::Server [ $alias, $rcode, \@ans, \@auth, \@add , $aa] (?)
 - ::Server stores ::Sink responses in $_[HEAP]->{PENDING}->{$alias}->{$query_class}->{$query_type}->{$query_record} = { hash data structure }
 - ::Server on receiving responses checks if all sink_aliases have filled in the structure
   - if yes, fire ::Server check_censor for each authority & additional record
     - check_sensor posts to sink_aliases 

POE event boilerplate:
  sub handle_event {
    my ($kernel, $heap, $parameter) = @_[KERNEL, HEAP, ARG0]; # @_[OBJECT]
    ...;
  }

DETAILS:
 - initialize greysink DNS stuff in an object
   - configure/populate the records inside it
 - Set up POE handling of DNS as an object state
 - Set up POE handling of config file as inline states
